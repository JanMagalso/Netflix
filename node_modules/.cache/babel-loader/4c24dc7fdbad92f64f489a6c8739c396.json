{"ast":null,"code":"/**\n * Copyright 2013-2014 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @providesModule DOMChildrenOperations\n * @typechecks static-only\n */\n\"use strict\";\n\nvar Danger = require(\"./Danger\");\n\nvar ReactMultiChildUpdateTypes = require(\"./ReactMultiChildUpdateTypes\");\n\nvar getTextContentAccessor = require(\"./getTextContentAccessor\");\n/**\n * The DOM property to use when setting text content.\n *\n * @type {string}\n * @private\n */\n\n\nvar textContentAccessor = getTextContentAccessor();\n/**\n * Inserts `childNode` as a child of `parentNode` at the `index`.\n *\n * @param {DOMElement} parentNode Parent node in which to insert.\n * @param {DOMElement} childNode Child node to insert.\n * @param {number} index Index at which to insert the child.\n * @internal\n */\n\nfunction insertChildAt(parentNode, childNode, index) {\n  var childNodes = parentNode.childNodes;\n\n  if (childNodes[index] === childNode) {\n    return;\n  } // If `childNode` is already a child of `parentNode`, remove it so that\n  // computing `childNodes[index]` takes into account the removal.\n\n\n  if (childNode.parentNode === parentNode) {\n    parentNode.removeChild(childNode);\n  }\n\n  if (index >= childNodes.length) {\n    parentNode.appendChild(childNode);\n  } else {\n    parentNode.insertBefore(childNode, childNodes[index]);\n  }\n}\n\nvar updateTextContent;\n\nif (textContentAccessor === 'textContent') {\n  /**\n   * Sets the text content of `node` to `text`.\n   *\n   * @param {DOMElement} node Node to change\n   * @param {string} text New text content\n   */\n  updateTextContent = function (node, text) {\n    node.textContent = text;\n  };\n} else {\n  /**\n   * Sets the text content of `node` to `text`.\n   *\n   * @param {DOMElement} node Node to change\n   * @param {string} text New text content\n   */\n  updateTextContent = function (node, text) {\n    // In order to preserve newlines correctly, we can't use .innerText to set\n    // the contents (see #1080), so we empty the element then append a text node\n    while (node.firstChild) {\n      node.removeChild(node.firstChild);\n    }\n\n    if (text) {\n      var doc = node.ownerDocument || document;\n      node.appendChild(doc.createTextNode(text));\n    }\n  };\n}\n/**\n * Operations for updating with DOM children.\n */\n\n\nvar DOMChildrenOperations = {\n  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,\n  updateTextContent: updateTextContent,\n\n  /**\n   * Updates a component's children by processing a series of updates. The\n   * update configurations are each expected to have a `parentNode` property.\n   *\n   * @param {array<object>} updates List of update configurations.\n   * @param {array<string>} markupList List of markup strings.\n   * @internal\n   */\n  processUpdates: function (updates, markupList) {\n    var update; // Mapping from parent IDs to initial child orderings.\n\n    var initialChildren = null; // List of children that will be moved or removed.\n\n    var updatedChildren = null;\n\n    for (var i = 0; update = updates[i]; i++) {\n      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {\n        var updatedIndex = update.fromIndex;\n        var updatedChild = update.parentNode.childNodes[updatedIndex];\n        var parentID = update.parentID;\n        initialChildren = initialChildren || {};\n        initialChildren[parentID] = initialChildren[parentID] || [];\n        initialChildren[parentID][updatedIndex] = updatedChild;\n        updatedChildren = updatedChildren || [];\n        updatedChildren.push(updatedChild);\n      }\n    }\n\n    var renderedMarkup = Danger.dangerouslyRenderMarkup(markupList); // Remove updated children first so that `toIndex` is consistent.\n\n    if (updatedChildren) {\n      for (var j = 0; j < updatedChildren.length; j++) {\n        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);\n      }\n    }\n\n    for (var k = 0; update = updates[k]; k++) {\n      switch (update.type) {\n        case ReactMultiChildUpdateTypes.INSERT_MARKUP:\n          insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);\n          break;\n\n        case ReactMultiChildUpdateTypes.MOVE_EXISTING:\n          insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);\n          break;\n\n        case ReactMultiChildUpdateTypes.TEXT_CONTENT:\n          updateTextContent(update.parentNode, update.textContent);\n          break;\n\n        case ReactMultiChildUpdateTypes.REMOVE_NODE:\n          // Already removed by the for-loop above.\n          break;\n      }\n    }\n  }\n};\nmodule.exports = DOMChildrenOperations;","map":{"version":3,"sources":["/home/dna-dev/Documents/react-web/node_modules/react-component/lib/DOMChildrenOperations.js"],"names":["Danger","require","ReactMultiChildUpdateTypes","getTextContentAccessor","textContentAccessor","insertChildAt","parentNode","childNode","index","childNodes","removeChild","length","appendChild","insertBefore","updateTextContent","node","text","textContent","firstChild","doc","ownerDocument","document","createTextNode","DOMChildrenOperations","dangerouslyReplaceNodeWithMarkup","processUpdates","updates","markupList","update","initialChildren","updatedChildren","i","type","MOVE_EXISTING","REMOVE_NODE","updatedIndex","fromIndex","updatedChild","parentID","push","renderedMarkup","dangerouslyRenderMarkup","j","k","INSERT_MARKUP","markupIndex","toIndex","TEXT_CONTENT","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-2014 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @providesModule DOMChildrenOperations\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar Danger = require(\"./Danger\");\nvar ReactMultiChildUpdateTypes = require(\"./ReactMultiChildUpdateTypes\");\n\nvar getTextContentAccessor = require(\"./getTextContentAccessor\");\n\n/**\n * The DOM property to use when setting text content.\n *\n * @type {string}\n * @private\n */\nvar textContentAccessor = getTextContentAccessor();\n\n/**\n * Inserts `childNode` as a child of `parentNode` at the `index`.\n *\n * @param {DOMElement} parentNode Parent node in which to insert.\n * @param {DOMElement} childNode Child node to insert.\n * @param {number} index Index at which to insert the child.\n * @internal\n */\nfunction insertChildAt(parentNode, childNode, index) {\n  var childNodes = parentNode.childNodes;\n  if (childNodes[index] === childNode) {\n    return;\n  }\n  // If `childNode` is already a child of `parentNode`, remove it so that\n  // computing `childNodes[index]` takes into account the removal.\n  if (childNode.parentNode === parentNode) {\n    parentNode.removeChild(childNode);\n  }\n  if (index >= childNodes.length) {\n    parentNode.appendChild(childNode);\n  } else {\n    parentNode.insertBefore(childNode, childNodes[index]);\n  }\n}\n\nvar updateTextContent;\nif (textContentAccessor === 'textContent') {\n  /**\n   * Sets the text content of `node` to `text`.\n   *\n   * @param {DOMElement} node Node to change\n   * @param {string} text New text content\n   */\n  updateTextContent = function(node, text) {\n    node.textContent = text;\n  };\n} else {\n  /**\n   * Sets the text content of `node` to `text`.\n   *\n   * @param {DOMElement} node Node to change\n   * @param {string} text New text content\n   */\n  updateTextContent = function(node, text) {\n    // In order to preserve newlines correctly, we can't use .innerText to set\n    // the contents (see #1080), so we empty the element then append a text node\n    while (node.firstChild) {\n      node.removeChild(node.firstChild);\n    }\n    if (text) {\n      var doc = node.ownerDocument || document;\n      node.appendChild(doc.createTextNode(text));\n    }\n  };\n}\n\n/**\n * Operations for updating with DOM children.\n */\nvar DOMChildrenOperations = {\n\n  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,\n\n  updateTextContent: updateTextContent,\n\n  /**\n   * Updates a component's children by processing a series of updates. The\n   * update configurations are each expected to have a `parentNode` property.\n   *\n   * @param {array<object>} updates List of update configurations.\n   * @param {array<string>} markupList List of markup strings.\n   * @internal\n   */\n  processUpdates: function(updates, markupList) {\n    var update;\n    // Mapping from parent IDs to initial child orderings.\n    var initialChildren = null;\n    // List of children that will be moved or removed.\n    var updatedChildren = null;\n\n    for (var i = 0; update = updates[i]; i++) {\n      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING ||\n          update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {\n        var updatedIndex = update.fromIndex;\n        var updatedChild = update.parentNode.childNodes[updatedIndex];\n        var parentID = update.parentID;\n\n        initialChildren = initialChildren || {};\n        initialChildren[parentID] = initialChildren[parentID] || [];\n        initialChildren[parentID][updatedIndex] = updatedChild;\n\n        updatedChildren = updatedChildren || [];\n        updatedChildren.push(updatedChild);\n      }\n    }\n\n    var renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);\n\n    // Remove updated children first so that `toIndex` is consistent.\n    if (updatedChildren) {\n      for (var j = 0; j < updatedChildren.length; j++) {\n        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);\n      }\n    }\n\n    for (var k = 0; update = updates[k]; k++) {\n      switch (update.type) {\n        case ReactMultiChildUpdateTypes.INSERT_MARKUP:\n          insertChildAt(\n            update.parentNode,\n            renderedMarkup[update.markupIndex],\n            update.toIndex\n          );\n          break;\n        case ReactMultiChildUpdateTypes.MOVE_EXISTING:\n          insertChildAt(\n            update.parentNode,\n            initialChildren[update.parentID][update.fromIndex],\n            update.toIndex\n          );\n          break;\n        case ReactMultiChildUpdateTypes.TEXT_CONTENT:\n          updateTextContent(\n            update.parentNode,\n            update.textContent\n          );\n          break;\n        case ReactMultiChildUpdateTypes.REMOVE_NODE:\n          // Already removed by the for-loop above.\n          break;\n      }\n    }\n  }\n\n};\n\nmodule.exports = DOMChildrenOperations;\n"]},"metadata":{},"sourceType":"script"}