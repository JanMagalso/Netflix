{"ast":null,"code":"/**\n * Copyright 2013-2014 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @providesModule ReactDefaultPerfAnalysis\n */\nvar merge = require(\"./merge\"); // Don't try to save users less than 1.2ms (a number I made up)\n\n\nvar DONT_CARE_THRESHOLD = 1.2;\nvar DOM_OPERATION_TYPES = {\n  'mountImageIntoNode': 'set innerHTML',\n  INSERT_MARKUP: 'set innerHTML',\n  MOVE_EXISTING: 'move',\n  REMOVE_NODE: 'remove',\n  TEXT_CONTENT: 'set textContent',\n  'updatePropertyByID': 'update attribute',\n  'deletePropertyByID': 'delete attribute',\n  'updateStylesByID': 'update styles',\n  'updateInnerHTMLByID': 'set innerHTML',\n  'dangerouslyReplaceNodeWithMarkupByID': 'replace'\n};\n\nfunction getTotalTime(measurements) {\n  // TODO: return number of DOM ops? could be misleading.\n  // TODO: measure dropped frames after reconcile?\n  // TODO: log total time of each reconcile and the top-level component\n  // class that triggered it.\n  var totalTime = 0;\n\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    totalTime += measurement.totalTime;\n  }\n\n  return totalTime;\n}\n\nfunction getDOMSummary(measurements) {\n  var items = [];\n\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    var id;\n\n    for (id in measurement.writes) {\n      measurement.writes[id].forEach(function (write) {\n        items.push({\n          id: id,\n          type: DOM_OPERATION_TYPES[write.type] || write.type,\n          args: write.args\n        });\n      });\n    }\n  }\n\n  return items;\n}\n\nfunction getExclusiveSummary(measurements) {\n  var candidates = {};\n  var displayName;\n\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    var allIDs = merge(measurement.exclusive, measurement.inclusive);\n\n    for (var id in allIDs) {\n      displayName = measurement.displayNames[id].current;\n      candidates[displayName] = candidates[displayName] || {\n        componentName: displayName,\n        inclusive: 0,\n        exclusive: 0,\n        count: 0\n      };\n\n      if (measurement.exclusive[id]) {\n        candidates[displayName].exclusive += measurement.exclusive[id];\n      }\n\n      if (measurement.inclusive[id]) {\n        candidates[displayName].inclusive += measurement.inclusive[id];\n      }\n\n      if (measurement.counts[id]) {\n        candidates[displayName].count += measurement.counts[id];\n      }\n    }\n  } // Now make a sorted array with the results.\n\n\n  var arr = [];\n\n  for (displayName in candidates) {\n    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {\n      arr.push(candidates[displayName]);\n    }\n  }\n\n  arr.sort(function (a, b) {\n    return b.exclusive - a.exclusive;\n  });\n  return arr;\n}\n\nfunction getInclusiveSummary(measurements, onlyClean) {\n  var candidates = {};\n  var inclusiveKey;\n\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    var allIDs = merge(measurement.exclusive, measurement.inclusive);\n    var cleanComponents;\n\n    if (onlyClean) {\n      cleanComponents = getUnchangedComponents(measurement);\n    }\n\n    for (var id in allIDs) {\n      if (onlyClean && !cleanComponents[id]) {\n        continue;\n      }\n\n      var displayName = measurement.displayNames[id]; // Inclusive time is not useful for many components without knowing where\n      // they are instantiated. So we aggregate inclusive time with both the\n      // owner and current displayName as the key.\n\n      inclusiveKey = displayName.owner + ' > ' + displayName.current;\n      candidates[inclusiveKey] = candidates[inclusiveKey] || {\n        componentName: inclusiveKey,\n        time: 0,\n        count: 0\n      };\n\n      if (measurement.inclusive[id]) {\n        candidates[inclusiveKey].time += measurement.inclusive[id];\n      }\n\n      if (measurement.counts[id]) {\n        candidates[inclusiveKey].count += measurement.counts[id];\n      }\n    }\n  } // Now make a sorted array with the results.\n\n\n  var arr = [];\n\n  for (inclusiveKey in candidates) {\n    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {\n      arr.push(candidates[inclusiveKey]);\n    }\n  }\n\n  arr.sort(function (a, b) {\n    return b.time - a.time;\n  });\n  return arr;\n}\n\nfunction getUnchangedComponents(measurement) {\n  // For a given reconcile, look at which components did not actually\n  // render anything to the DOM and return a mapping of their ID to\n  // the amount of time it took to render the entire subtree.\n  var cleanComponents = {};\n  var dirtyLeafIDs = Object.keys(measurement.writes);\n  var allIDs = merge(measurement.exclusive, measurement.inclusive);\n\n  for (var id in allIDs) {\n    var isDirty = false; // For each component that rendered, see if a component that triggerd\n    // a DOM op is in its subtree.\n\n    for (var i = 0; i < dirtyLeafIDs.length; i++) {\n      if (dirtyLeafIDs[i].indexOf(id) === 0) {\n        isDirty = true;\n        break;\n      }\n    }\n\n    if (!isDirty && measurement.counts[id] > 0) {\n      cleanComponents[id] = true;\n    }\n  }\n\n  return cleanComponents;\n}\n\nvar ReactDefaultPerfAnalysis = {\n  getExclusiveSummary: getExclusiveSummary,\n  getInclusiveSummary: getInclusiveSummary,\n  getDOMSummary: getDOMSummary,\n  getTotalTime: getTotalTime\n};\nmodule.exports = ReactDefaultPerfAnalysis;","map":{"version":3,"sources":["/home/dna-dev/Documents/react-web/node_modules/react-component/lib/ReactDefaultPerfAnalysis.js"],"names":["merge","require","DONT_CARE_THRESHOLD","DOM_OPERATION_TYPES","INSERT_MARKUP","MOVE_EXISTING","REMOVE_NODE","TEXT_CONTENT","getTotalTime","measurements","totalTime","i","length","measurement","getDOMSummary","items","id","writes","forEach","write","push","type","args","getExclusiveSummary","candidates","displayName","allIDs","exclusive","inclusive","displayNames","current","componentName","count","counts","arr","sort","a","b","getInclusiveSummary","onlyClean","inclusiveKey","cleanComponents","getUnchangedComponents","owner","time","dirtyLeafIDs","Object","keys","isDirty","indexOf","ReactDefaultPerfAnalysis","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-2014 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @providesModule ReactDefaultPerfAnalysis\n */\n\nvar merge = require(\"./merge\");\n\n// Don't try to save users less than 1.2ms (a number I made up)\nvar DONT_CARE_THRESHOLD = 1.2;\nvar DOM_OPERATION_TYPES = {\n  'mountImageIntoNode': 'set innerHTML',\n  INSERT_MARKUP: 'set innerHTML',\n  MOVE_EXISTING: 'move',\n  REMOVE_NODE: 'remove',\n  TEXT_CONTENT: 'set textContent',\n  'updatePropertyByID': 'update attribute',\n  'deletePropertyByID': 'delete attribute',\n  'updateStylesByID': 'update styles',\n  'updateInnerHTMLByID': 'set innerHTML',\n  'dangerouslyReplaceNodeWithMarkupByID': 'replace'\n};\n\nfunction getTotalTime(measurements) {\n  // TODO: return number of DOM ops? could be misleading.\n  // TODO: measure dropped frames after reconcile?\n  // TODO: log total time of each reconcile and the top-level component\n  // class that triggered it.\n  var totalTime = 0;\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    totalTime += measurement.totalTime;\n  }\n  return totalTime;\n}\n\nfunction getDOMSummary(measurements) {\n  var items = [];\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    var id;\n\n    for (id in measurement.writes) {\n      measurement.writes[id].forEach(function(write) {\n        items.push({\n          id: id,\n          type: DOM_OPERATION_TYPES[write.type] || write.type,\n          args: write.args\n        });\n      });\n    }\n  }\n  return items;\n}\n\nfunction getExclusiveSummary(measurements) {\n  var candidates = {};\n  var displayName;\n\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    var allIDs = merge(measurement.exclusive, measurement.inclusive);\n\n    for (var id in allIDs) {\n      displayName = measurement.displayNames[id].current;\n\n      candidates[displayName] = candidates[displayName] || {\n        componentName: displayName,\n        inclusive: 0,\n        exclusive: 0,\n        count: 0\n      };\n      if (measurement.exclusive[id]) {\n        candidates[displayName].exclusive += measurement.exclusive[id];\n      }\n      if (measurement.inclusive[id]) {\n        candidates[displayName].inclusive += measurement.inclusive[id];\n      }\n      if (measurement.counts[id]) {\n        candidates[displayName].count += measurement.counts[id];\n      }\n    }\n  }\n\n  // Now make a sorted array with the results.\n  var arr = [];\n  for (displayName in candidates) {\n    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {\n      arr.push(candidates[displayName]);\n    }\n  }\n\n  arr.sort(function(a, b) {\n    return b.exclusive - a.exclusive;\n  });\n\n  return arr;\n}\n\nfunction getInclusiveSummary(measurements, onlyClean) {\n  var candidates = {};\n  var inclusiveKey;\n\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    var allIDs = merge(measurement.exclusive, measurement.inclusive);\n    var cleanComponents;\n\n    if (onlyClean) {\n      cleanComponents = getUnchangedComponents(measurement);\n    }\n\n    for (var id in allIDs) {\n      if (onlyClean && !cleanComponents[id]) {\n        continue;\n      }\n\n      var displayName = measurement.displayNames[id];\n\n      // Inclusive time is not useful for many components without knowing where\n      // they are instantiated. So we aggregate inclusive time with both the\n      // owner and current displayName as the key.\n      inclusiveKey = displayName.owner + ' > ' + displayName.current;\n\n      candidates[inclusiveKey] = candidates[inclusiveKey] || {\n        componentName: inclusiveKey,\n        time: 0,\n        count: 0\n      };\n\n      if (measurement.inclusive[id]) {\n        candidates[inclusiveKey].time += measurement.inclusive[id];\n      }\n      if (measurement.counts[id]) {\n        candidates[inclusiveKey].count += measurement.counts[id];\n      }\n    }\n  }\n\n  // Now make a sorted array with the results.\n  var arr = [];\n  for (inclusiveKey in candidates) {\n    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {\n      arr.push(candidates[inclusiveKey]);\n    }\n  }\n\n  arr.sort(function(a, b) {\n    return b.time - a.time;\n  });\n\n  return arr;\n}\n\nfunction getUnchangedComponents(measurement) {\n  // For a given reconcile, look at which components did not actually\n  // render anything to the DOM and return a mapping of their ID to\n  // the amount of time it took to render the entire subtree.\n  var cleanComponents = {};\n  var dirtyLeafIDs = Object.keys(measurement.writes);\n  var allIDs = merge(measurement.exclusive, measurement.inclusive);\n\n  for (var id in allIDs) {\n    var isDirty = false;\n    // For each component that rendered, see if a component that triggerd\n    // a DOM op is in its subtree.\n    for (var i = 0; i < dirtyLeafIDs.length; i++) {\n      if (dirtyLeafIDs[i].indexOf(id) === 0) {\n        isDirty = true;\n        break;\n      }\n    }\n    if (!isDirty && measurement.counts[id] > 0) {\n      cleanComponents[id] = true;\n    }\n  }\n  return cleanComponents;\n}\n\nvar ReactDefaultPerfAnalysis = {\n  getExclusiveSummary: getExclusiveSummary,\n  getInclusiveSummary: getInclusiveSummary,\n  getDOMSummary: getDOMSummary,\n  getTotalTime: getTotalTime\n};\n\nmodule.exports = ReactDefaultPerfAnalysis;\n"]},"metadata":{},"sourceType":"script"}