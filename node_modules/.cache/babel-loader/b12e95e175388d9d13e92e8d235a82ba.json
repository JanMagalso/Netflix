{"ast":null,"code":"/**\n * Copyright 2013-2014 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @providesModule traverseAllChildren\n */\n\"use strict\";\n\nvar ReactInstanceHandles = require(\"./ReactInstanceHandles\");\n\nvar ReactTextComponent = require(\"./ReactTextComponent\");\n\nvar invariant = require(\"./invariant\");\n\nvar SEPARATOR = ReactInstanceHandles.SEPARATOR;\nvar SUBSEPARATOR = ':';\n/**\n * TODO: Test that:\n * 1. `mapChildren` transforms strings and numbers into `ReactTextComponent`.\n * 2. it('should fail when supplied duplicate key', function() {\n * 3. That a single child and an array with one item have the same key pattern.\n * });\n */\n\nvar userProvidedKeyEscaperLookup = {\n  '=': '=0',\n  '.': '=1',\n  ':': '=2'\n};\nvar userProvidedKeyEscapeRegex = /[=.:]/g;\n\nfunction userProvidedKeyEscaper(match) {\n  return userProvidedKeyEscaperLookup[match];\n}\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\n\n\nfunction getComponentKey(component, index) {\n  if (component && component.props && component.props.key != null) {\n    // Explicit key\n    return wrapUserProvidedKey(component.props.key);\n  } // Implicit key determined by the index in the set\n\n\n  return index.toString(36);\n}\n/**\n * Escape a component key so that it is safe to use in a reactid.\n *\n * @param {*} key Component key to be escaped.\n * @return {string} An escaped string.\n */\n\n\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);\n}\n/**\n * Wrap a `key` value explicitly provided by the user to distinguish it from\n * implicitly-generated keys generated by a component's index in its parent.\n *\n * @param {string} key Value of a user-provided `key` attribute\n * @return {string}\n */\n\n\nfunction wrapUserProvidedKey(key) {\n  return '$' + escapeUserProvidedKey(key);\n}\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!number} indexSoFar Number of children encountered until this point.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\n\n\nvar traverseAllChildrenImpl = function (children, nameSoFar, indexSoFar, callback, traverseContext) {\n  var subtreeCount = 0; // Count of children found in the current subtree.\n\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n      var nextName = nameSoFar + (nameSoFar ? SUBSEPARATOR : SEPARATOR) + getComponentKey(child, i);\n      var nextIndex = indexSoFar + subtreeCount;\n      subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext);\n    }\n  } else {\n    var type = typeof children;\n    var isOnlyChild = nameSoFar === ''; // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows\n\n    var storageName = isOnlyChild ? SEPARATOR + getComponentKey(children, 0) : nameSoFar;\n\n    if (children == null || type === 'boolean') {\n      // All of the above are perceived as null.\n      callback(traverseContext, null, storageName, indexSoFar);\n      subtreeCount = 1;\n    } else if (children.type && children.type.prototype && children.type.prototype.mountComponentIntoNode) {\n      callback(traverseContext, children, storageName, indexSoFar);\n      subtreeCount = 1;\n    } else {\n      if (type === 'object') {\n        require('./React').__DEV__ === true ? invariant(!children || children.nodeType !== 1, 'traverseAllChildren(...): Encountered an invalid child; DOM ' + 'elements are not valid children of React components.') : invariant(!children || children.nodeType !== 1);\n\n        for (var key in children) {\n          if (children.hasOwnProperty(key)) {\n            subtreeCount += traverseAllChildrenImpl(children[key], nameSoFar + (nameSoFar ? SUBSEPARATOR : SEPARATOR) + wrapUserProvidedKey(key) + SUBSEPARATOR + getComponentKey(children[key], 0), indexSoFar + subtreeCount, callback, traverseContext);\n          }\n        }\n      } else if (type === 'string') {\n        var normalizedText = new ReactTextComponent(children);\n        callback(traverseContext, normalizedText, storageName, indexSoFar);\n        subtreeCount += 1;\n      } else if (type === 'number') {\n        var normalizedNumber = new ReactTextComponent('' + children);\n        callback(traverseContext, normalizedNumber, storageName, indexSoFar);\n        subtreeCount += 1;\n      }\n    }\n  }\n\n  return subtreeCount;\n};\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n */\n\n\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children !== null && children !== undefined) {\n    traverseAllChildrenImpl(children, '', 0, callback, traverseContext);\n  }\n}\n\nmodule.exports = traverseAllChildren;","map":{"version":3,"sources":["/home/dna-dev/Documents/react-web/node_modules/react-component/lib/traverseAllChildren.js"],"names":["ReactInstanceHandles","require","ReactTextComponent","invariant","SEPARATOR","SUBSEPARATOR","userProvidedKeyEscaperLookup","userProvidedKeyEscapeRegex","userProvidedKeyEscaper","match","getComponentKey","component","index","props","key","wrapUserProvidedKey","toString","escapeUserProvidedKey","text","replace","traverseAllChildrenImpl","children","nameSoFar","indexSoFar","callback","traverseContext","subtreeCount","Array","isArray","i","length","child","nextName","nextIndex","type","isOnlyChild","storageName","prototype","mountComponentIntoNode","__DEV__","nodeType","hasOwnProperty","normalizedText","normalizedNumber","traverseAllChildren","undefined","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-2014 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @providesModule traverseAllChildren\n */\n\n\"use strict\";\n\nvar ReactInstanceHandles = require(\"./ReactInstanceHandles\");\nvar ReactTextComponent = require(\"./ReactTextComponent\");\n\nvar invariant = require(\"./invariant\");\n\nvar SEPARATOR = ReactInstanceHandles.SEPARATOR;\nvar SUBSEPARATOR = ':';\n\n/**\n * TODO: Test that:\n * 1. `mapChildren` transforms strings and numbers into `ReactTextComponent`.\n * 2. it('should fail when supplied duplicate key', function() {\n * 3. That a single child and an array with one item have the same key pattern.\n * });\n */\n\nvar userProvidedKeyEscaperLookup = {\n  '=': '=0',\n  '.': '=1',\n  ':': '=2'\n};\n\nvar userProvidedKeyEscapeRegex = /[=.:]/g;\n\nfunction userProvidedKeyEscaper(match) {\n  return userProvidedKeyEscaperLookup[match];\n}\n\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getComponentKey(component, index) {\n  if (component && component.props && component.props.key != null) {\n    // Explicit key\n    return wrapUserProvidedKey(component.props.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\n/**\n * Escape a component key so that it is safe to use in a reactid.\n *\n * @param {*} key Component key to be escaped.\n * @return {string} An escaped string.\n */\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(\n    userProvidedKeyEscapeRegex,\n    userProvidedKeyEscaper\n  );\n}\n\n/**\n * Wrap a `key` value explicitly provided by the user to distinguish it from\n * implicitly-generated keys generated by a component's index in its parent.\n *\n * @param {string} key Value of a user-provided `key` attribute\n * @return {string}\n */\nfunction wrapUserProvidedKey(key) {\n  return '$' + escapeUserProvidedKey(key);\n}\n\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!number} indexSoFar Number of children encountered until this point.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\nvar traverseAllChildrenImpl =\n  function(children, nameSoFar, indexSoFar, callback, traverseContext) {\n    var subtreeCount = 0;  // Count of children found in the current subtree.\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        var nextName = (\n          nameSoFar +\n          (nameSoFar ? SUBSEPARATOR : SEPARATOR) +\n          getComponentKey(child, i)\n        );\n        var nextIndex = indexSoFar + subtreeCount;\n        subtreeCount += traverseAllChildrenImpl(\n          child,\n          nextName,\n          nextIndex,\n          callback,\n          traverseContext\n        );\n      }\n    } else {\n      var type = typeof children;\n      var isOnlyChild = nameSoFar === '';\n      // If it's the only child, treat the name as if it was wrapped in an array\n      // so that it's consistent if the number of children grows\n      var storageName =\n        isOnlyChild ? SEPARATOR + getComponentKey(children, 0) : nameSoFar;\n      if (children == null || type === 'boolean') {\n        // All of the above are perceived as null.\n        callback(traverseContext, null, storageName, indexSoFar);\n        subtreeCount = 1;\n      } else if (children.type && children.type.prototype &&\n                 children.type.prototype.mountComponentIntoNode) {\n        callback(traverseContext, children, storageName, indexSoFar);\n        subtreeCount = 1;\n      } else {\n        if (type === 'object') {\n          (require('./React').__DEV__ === true ? invariant(\n            !children || children.nodeType !== 1,\n            'traverseAllChildren(...): Encountered an invalid child; DOM ' +\n            'elements are not valid children of React components.'\n          ) : invariant(!children || children.nodeType !== 1));\n          for (var key in children) {\n            if (children.hasOwnProperty(key)) {\n              subtreeCount += traverseAllChildrenImpl(\n                children[key],\n                (\n                  nameSoFar + (nameSoFar ? SUBSEPARATOR : SEPARATOR) +\n                  wrapUserProvidedKey(key) + SUBSEPARATOR +\n                  getComponentKey(children[key], 0)\n                ),\n                indexSoFar + subtreeCount,\n                callback,\n                traverseContext\n              );\n            }\n          }\n        } else if (type === 'string') {\n          var normalizedText = new ReactTextComponent(children);\n          callback(traverseContext, normalizedText, storageName, indexSoFar);\n          subtreeCount += 1;\n        } else if (type === 'number') {\n          var normalizedNumber = new ReactTextComponent('' + children);\n          callback(traverseContext, normalizedNumber, storageName, indexSoFar);\n          subtreeCount += 1;\n        }\n      }\n    }\n    return subtreeCount;\n  };\n\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n */\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children !== null && children !== undefined) {\n    traverseAllChildrenImpl(children, '', 0, callback, traverseContext);\n  }\n}\n\nmodule.exports = traverseAllChildren;\n"]},"metadata":{},"sourceType":"script"}